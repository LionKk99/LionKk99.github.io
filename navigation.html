---
layout: null
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Side of the Moon - Prism</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        .scene-container {
            width: 100%;
            max-width: 1100px;
            position: relative;
        }

        svg {
            width: 100%;
            height: auto;
            overflow: visible;
        }

        /* --- 1. 棱镜样式 (实物感) --- */
        .prism {
            fill: #0a0a0a; /* 接近黑色 */
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 1;
            /* 外部辉光滤镜在 SVG defs 中定义 */
        }

        /* --- 2. 光线样式 --- */
        .white-light {
            stroke: #fff;
            stroke-width: 2.5;
            opacity: 0.95;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
            stroke-linecap: round;
        }

        /* 内部光路 (三角形) */
        .internal-light-path {
            /* 填充色在 SVG 中引用渐变 */
            opacity: 0.6; 
            pointer-events: none;
            mix-blend-mode: screen; /* 混合模式让光看起来更亮 */
        }

        /* 外部光束 */
        .beam {
            cursor: pointer;
            opacity: 0.7; 
            transition: opacity 0.3s;
        }
        
        .beam:hover {
            opacity: 1;
            filter: drop-shadow(0 0 10px currentColor);
            z-index: 10;
        }

        /* --- 3. 文字样式 --- */
        .beam-text {
            fill: white;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            pointer-events: none; 
            opacity: 0;
            transition: opacity 0.2s;
            text-anchor: start; /* 左对齐 */
            dominant-baseline: middle; 
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }

        .beam-group:hover .beam-text {
            opacity: 1;
        }

        /* --- 颜色定义 --- */
        .color-red    { fill: #ff0000; color: #ff0000; }
        .color-orange { fill: #ff7f00; color: #ff7f00; }
        .color-yellow { fill: #ffff00; color: #ffff00; }
        .color-green  { fill: #00ff00; color: #00ff00; }
        .color-blue   { fill: #0000ff; color: #0000ff; }
        .color-purple { fill: #8b00ff; color: #8b00ff; }

        /* 返回按钮 */
        .back-home {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            transition: 0.3s;
            z-index: 100;
        }
        .back-home:hover {
            color: white;
            border-color: white;
            background: rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>

    <a href="/" class="back-home">← Back to Home</a>

    <div class="scene-container">
        <svg viewBox="0 0 1000 600" id="main-svg">
            
            <defs>
                <filter id="prism-glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="15" result="blur" />
                    <feColorMatrix in="blur" type="matrix" values="
                        0 0 0 0 1 
                        0 0 0 0 1 
                        0 0 0 0 1 
                        0 0 0 0.15 0" result="glow" />
                    <feMerge>
                        <feMergeNode in="glow" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>

                <linearGradient id="internal-grad" x1="0%" y1="50%" x2="100%" y2="50%">
                    <stop offset="0%" style="stop-color:rgb(255,255,255);stop-opacity:0.9" />
                    <stop offset="60%" style="stop-color:rgb(255,255,255);stop-opacity:0.1" />
                    <stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:0" />
                </linearGradient>
            </defs>

            <polygon points="400,450 600,450 500,250" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="20" style="filter: blur(10px);" />

            <path id="internal-light" class="internal-light-path" fill="url(#internal-grad)" d="" />

            <polygon class="prism" points="400,450 600,450 500,250" filter="url(#prism-glow)" />

            <line x1="-50" y1="380" x2="435" y2="335" class="white-light" />

            <g id="spectrum-layer">
                <a href="/category/transformer" class="beam-group" data-index="0">
                    <path class="beam color-red" d="" />
                    <text class="beam-text" x="0" y="0">Transformer</text>
                </a>
                <a href="/category/machine-learning" class="beam-group" data-index="1">
                    <path class="beam color-orange" d="" />
                    <text class="beam-text" x="0" y="0">ML / DL</text>
                </a>
                <a href="/category/math" class="beam-group" data-index="2">
                    <path class="beam color-yellow" d="" />
                    <text class="beam-text" x="0" y="0">Math</text>
                </a>
                <a href="/archives" class="beam-group" data-index="3">
                    <path class="beam color-green" d="" />
                    <text class="beam-text" x="0" y="0">Archives</text>
                </a>
                <a href="/about" class="beam-group" data-index="4">
                    <path class="beam color-blue" d="" />
                    <text class="beam-text" x="0" y="0">About</text>
                </a>
                <a href="https://github.com/LionKk99" class="beam-group" data-index="5">
                    <path class="beam color-purple" d="" />
                    <text class="beam-text" x="0" y="0">GitHub</text>
                </a>
            </g>
        </svg>
    </div>

    <script>
        // === 几何配置 ===
        
        // 1. 中心轴线 Y (Center Axis)
        // 这是白光入射的高度，也是光谱展开的中心轴
        const CENTER_Y = 335; 

        // 2. 关键X坐标
        // 内部光路起点 (入射点)
        const ENTRY_POINT = { x: 435, y: 335 };
        // 棱镜出射面 X 坐标 (光谱开始的地方)
        const EXIT_X = 535; 
        // 屏幕右边缘
        const END_X = 1100;

        // 3. 高度配置
        // 静止时的光谱总高度 (较窄，为了平行感)
        const IDLE_TOTAL_HEIGHT = 120; 
        // 激活时的光谱总高度 (展开)
        const ACTIVE_TOTAL_HEIGHT = 300; 

        // 动画参数
        const LERP_FACTOR = 0.1;
        const ACTIVE_WEIGHT = 6; 
        const NORMAL_WEIGHT = 1;

        // === DOM 元素 ===
        const groups = document.querySelectorAll('.beam-group');
        const paths = document.querySelectorAll('.beam');
        const texts = document.querySelectorAll('.beam-text');
        const internalLightPath = document.getElementById('internal-light');
        
        // 权重状态
        let currentWeights = [1, 1, 1, 1, 1, 1];
        let targetWeights = [1, 1, 1, 1, 1, 1];

        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        // === 动画循环 ===
        function animate() {
            // 1. 计算权重
            let totalWeight = 0;
            let isHovering = false;

            for (let i = 0; i < 6; i++) {
                // 平滑过渡权重
                if (Math.abs(targetWeights[i] - currentWeights[i]) > 0.001) {
                    currentWeights[i] = lerp(currentWeights[i], targetWeights[i], LERP_FACTOR);
                } else {
                    currentWeights[i] = targetWeights[i];
                }
                
                totalWeight += currentWeights[i];
                if (targetWeights[i] > 1.1) isHovering = true;
            }

            // 2. 计算当前的动态总高度
            // 根据 totalWeight 的大小来决定总高度
            // 如果 totalWeight 接近 6 (默认)，高度接近 IDLE_TOTAL_HEIGHT
            // 如果 totalWeight 接近 (5 + ACTIVE_WEIGHT)，高度接近 ACTIVE_TOTAL_HEIGHT
            const maxWeight = 5 + ACTIVE_WEIGHT;
            const ratio = (totalWeight - 6) / (maxWeight - 6); // 0 到 1
            const currentTotalHeight = lerp(IDLE_TOTAL_HEIGHT, ACTIVE_TOTAL_HEIGHT, ratio);

            // 3. 核心逻辑：中心对称计算
            // 起始 Y 坐标 = 中心线 - (总高度的一半)
            // 这样无论怎么变，中间那条缝永远在 CENTER_Y 上
            let currentY = CENTER_Y - (currentTotalHeight / 2);
            
            // 记录最上端和最下端的Y，用于绘制内部三角形
            const topY = currentY;

            // 4. 绘制外部光束
            for (let i = 0; i < 6; i++) {
                const height = (currentWeights[i] / totalWeight) * currentTotalHeight;
                const y1 = currentY;
                const y2 = currentY + height;

                // 绘制梯形：左边是(EXIT_X)，右边是(END_X)
                // 注意：保持 y1 和 y2 水平延伸，实现"平行"感
                const d = `M ${EXIT_X} ${y1} L ${END_X} ${y1} L ${END_X} ${y2} L ${EXIT_X} ${y2} Z`;
                paths[i].setAttribute('d', d);

                // 文字位置：放在光束内部左侧
                const textX = EXIT_X + 20 + (currentWeights[i] * 5); 
                const textY = y1 + height / 2 + 1;
                texts[i].setAttribute('x', textX);
                texts[i].setAttribute('y', textY);

                currentY += height;
            }

            const bottomY = currentY; // 循环结束后的 Y 就是最底部

            // 5. 绘制内部光路 (三角形)
            // 起点：入射点 ENTRY_POINT
            // 终点1：出射面最上端 (EXIT_X, topY)
            // 终点2：出射面最下端 (EXIT_X, bottomY)
            const internalD = `M ${ENTRY_POINT.x} ${ENTRY_POINT.y} L ${EXIT_X} ${topY} L ${EXIT_X} ${bottomY} Z`;
            internalLightPath.setAttribute('d', internalD);

            requestAnimationFrame(animate);
        }

        // === 事件监听 ===
        groups.forEach(group => {
            const index = parseInt(group.getAttribute('data-index'));

            group.addEventListener('mouseenter', () => {
                for (let i = 0; i < 6; i++) {
                    targetWeights[i] = (i === index) ? ACTIVE_WEIGHT : NORMAL_WEIGHT;
                }
            });

            group.addEventListener('mouseleave', () => {
                for (let i = 0; i < 6; i++) { targetWeights[i] = NORMAL_WEIGHT; }
            });
        });

        animate();

    </script>
</body>
</html>